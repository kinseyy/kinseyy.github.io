<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="kinsey"><meta name="copyright" content="kinsey"><meta name="generator" content="Hexo 7.2.0"><meta name="theme" content="hexo-theme-yun"><title>Java | 北歌</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/star-markdown-css@0.4.1/dist/yun/yun-markdown.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/prism-theme-vars/base.css"><script src="https://fastly.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".markdown-body img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link rel="stylesheet" type="text/css" href="https://fastly.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script defer src="https://fastly.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script><link rel="stylesheet" type="text/css" href="https://fastly.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.min.css"><script defer src="https://fastly.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.min.js"></script><script defer src="https://fastly.jsdelivr.net/npm/katex@latest/dist/contrib/auto-render.min.js"></script><script type="module">import { renderKatex } from '/js/utils.js'
document.addEventListener("DOMContentLoaded", () => {
  renderKatex({
    ...{},
    ...undefined?.options,
  });
});</script><link rel="icon" type="image/svg+xml" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#0078E7"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="preconnect" href="https://fastly.jsdelivr.net/npm/" crossorigin><script id="yun-config">
    window.Yun = {}
    window.CONFIG = {"hostname":"kinseyy.github.io","root":"/","title":"北沐城歌","version":"1.10.11","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}.","hits":"${hits} results found","hits_time":"${hits} results found in ${time} ms"},"anonymous_image":"https://cdn.yunyoujun.cn/img/avatar/none.jpg","say":{"api":"https://el-bot-api.vercel.app/api/words/young"},"algolia":{"appID":"LWKPDLFKV6","apiKey":"6f230e5e2cdf36415bd02b48c1138c08","indexName":"my-hexo-blog","hits":{"per_page":8}},"fireworks":{"colors":null},"waline":{"config":{"enable":true,"serverURL":"https://kinsey-six.vercel.app","comment":true,"visitor":true,"emoji":["https://fastly.jsdelivr.net/gh/walinejs/emojis@latest/bilibili/","https://fastly.jsdelivr.net/gh/walinejs/emojis@latest/weibo/","https://fastly.jsdelivr.net/gh/walinejs/emojis@latest/qq/"],"locale":{"placeholder":"填写邮箱，可以收到回复通知哦～"},"requiredMeta":["nick"],"el":"#waline","lang":"en"},"cdn":"https://fastly.jsdelivr.net/npm/@waline/client@v2/dist/waline.js","dark":"html.dark"},"vendors":{"host":"https://fastly.jsdelivr.net/npm/","darken":"https://fastly.jsdelivr.net/npm/darken@1.5.0"}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/hexo-theme-yun.js" type="module"></script><link rel="alternate" href="/atom.xml" title="北歌" type="application/atom+xml"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin><script async src="https://www.googletagmanager.com/gtag/js?id=G-1LL0D86CY9"></script><script>if (CONFIG.hostname === location.hostname) {
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-1LL0D86CY9');
}</script><script data-ad-client="ca-pub-2245427233262012" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(function(){
  var bp = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https') {
    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else {
    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})();</script><!-- Google Tag Manager --><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-M9KWR9L');</script><!-- End Google Tag Manager --><script>CONFIG.leancloudVisitors = {"enable":true,"app_id":"S8MhECl1Bg6fZt5ulKgIlajS-MdYXbMMI","app_key":"eLIsYKPJFnSJdwmHLoigqBR4","server_url":"https://s8mhecl1.api.lncldglobal.com"}</script><script defer src="/js/analytics/leancloud-visitors.js" type="module"></script><meta name="description" content="Java 注释単行注释格式    &#x2F;&#x2F;注释信息 多行注释格式    &#x2F;*注释信息*&#x2F; 文档注释格式    &#x2F;**注释信息*&#x2F; 关键字 class关键字用于（创建&#x2F;定义）一个类，类是Java最基本的组成单元 字面量 制表符\t 在打印时，把前面字符串长度补齐到8或者8的整数倍，最少一个空格，最多8个空格  变量名int  整数类型">
<meta property="og:type" content="article">
<meta property="og:title" content="Java">
<meta property="og:url" content="https://kinseyy.github.io/2024/11/12/Java/index.html">
<meta property="og:site_name" content="北歌">
<meta property="og:description" content="Java 注释単行注释格式    &#x2F;&#x2F;注释信息 多行注释格式    &#x2F;*注释信息*&#x2F; 文档注释格式    &#x2F;**注释信息*&#x2F; 关键字 class关键字用于（创建&#x2F;定义）一个类，类是Java最基本的组成单元 字面量 制表符\t 在打印时，把前面字符串长度补齐到8或者8的整数倍，最少一个空格，最多8个空格  变量名int  整数类型">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202410142030404.png">
<meta property="og:image" content="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202410142030688.png">
<meta property="og:image" content="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202410142034225.png">
<meta property="og:image" content="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202410142048988.png">
<meta property="og:image" content="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202410142037126.png">
<meta property="og:image" content="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202410142158637.png">
<meta property="og:image" content="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202410142200057.png">
<meta property="og:image" content="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202410142217870.png">
<meta property="og:image" content="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202410142224812.png">
<meta property="og:image" content="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202410142225733.png">
<meta property="og:image" content="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202410142228327.png">
<meta property="og:image" content="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202410142230328.png">
<meta property="og:image" content="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202410142232844.png">
<meta property="og:image" content="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202410151427720.png">
<meta property="og:image" content="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202410151431700.png">
<meta property="og:image" content="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202411242052644.png">
<meta property="og:image" content="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202411242204255.png">
<meta property="og:image" content="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202411242237542.png">
<meta property="og:image" content="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202411251911421.png">
<meta property="og:image" content="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202411252210243.png">
<meta property="og:image" content="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202411252231802.png">
<meta property="og:image" content="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202411261447025.png">
<meta property="og:image" content="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202411261503699.png">
<meta property="og:image" content="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202411261558114.png">
<meta property="og:image" content="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202411261625965.png">
<meta property="og:image" content="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202411261645171.png">
<meta property="og:image" content="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202411261950890.png">
<meta property="og:image" content="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202502181547149.png">
<meta property="og:image" content="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202411252031928.png">
<meta property="og:image" content="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202411252034486.png">
<meta property="og:image" content="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202411252127044.png">
<meta property="og:image" content="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202502181646735.png">
<meta property="og:image" content="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202502181657494.png">
<meta property="og:image" content="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202502181701119.png">
<meta property="og:image" content="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202502181855001.png">
<meta property="og:image" content="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202502181855366.png">
<meta property="og:image" content="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202502181917171.png">
<meta property="og:image" content="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202502181510170.png">
<meta property="og:image" content="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202504162109989.png">
<meta property="og:image" content="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202504171924853.png">
<meta property="og:image" content="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202504171940279.png">
<meta property="og:image" content="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202504172006574.png">
<meta property="og:image" content="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202504172030537.png">
<meta property="og:image" content="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202504172100106.png">
<meta property="og:image" content="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202504172132606.png">
<meta property="og:image" content="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202504172139792.png">
<meta property="article:published_time" content="2024-11-12T10:49:38.000Z">
<meta property="article:modified_time" content="2025-04-17T13:39:51.243Z">
<meta property="article:author" content="kinsey">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202410142030404.png"><script>(function() {
  if (CONFIG.mode !== 'auto') return
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  const setting = localStorage.getItem('darken-mode') || 'auto'
  if (setting === 'dark' || (prefersDark && setting !== 'light'))
    document.documentElement.classList.toggle('dark', true)
})()</script></head><body><script src="https://code.iconify.design/2/2.1.1/iconify.min.js"></script><script>// Define global variable
IconifyProviders = {
  // Empty prefix: overwrite default API provider configuration
  '': {
    // Use custom API first, use Iconify public API as backup
    resources: [
        'https://api.iconify.design',
    ],
    // Wait for 1 second before switching API hosts
    rotate: 1000,
  },
};</script><script defer src="https://fastly.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js" type="module"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js" type="module"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="Table of Contents"><span class="icon iconify" data-icon="ri:list-ordered"></span></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="Overview"><span class="icon iconify" data-icon="ri:passport-line"></span></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="kinsey"><img width="96" loading="lazy" src="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202405312004243.jpeg" alt="kinsey"><span class="site-author-status" title="Looking for dawn.">🌑</span></a><div class="site-author-name"><a href="/about/">kinsey</a></div><span class="site-name">北歌</span><sub class="site-subtitle"></sub><div class="site-description"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="Home"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:home-4-line"></span></span></a><div class="site-state-item"><a href="/archives/" title="Archives"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:archive-line"></span></span><span class="site-state-item-count">219</span></a></div><div class="site-state-item"><a href="/categories/" title="Categories"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:folder-2-line"></span></span><span class="site-state-item-count">7</span></a></div><div class="site-state-item"><a href="/tags/" title="Tags"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="site-state-item-count">101</span></a></div><a class="site-state-item hty-icon-button" href="/about/#comment" title="留言板"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:clipboard-line"></span></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="/atom.xml" title="RSS" target="_blank" style="color:orange"><span class="icon iconify" data-icon="ri:rss-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/kinseyy" title="GitHub" target="_blank" style="color:#6e5494"><span class="icon iconify" data-icon="ri:github-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/#/user/home?id=3954596483" title="网易云音乐" target="_blank" style="color:#C20C0C"><span class="icon iconify" data-icon="ri:netease-cloud-music-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://travellings.link" title="Travelling" target="_blank" style="color:var(--hty-text-color)"><span class="icon iconify" data-icon="ri:train-line"></span></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><span class="icon iconify" data-icon="ri:genderless-line"></span></a><a class="links-item hty-icon-button" href="/girls/" title="喜欢的女孩子" style="color:hotpink"><span class="icon iconify" data-icon="ri:women-line"></span></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><span class="icon iconify" data-icon="ri:contrast-2-line"></span></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java"><span class="toc-number">1.</span> <span class="toc-text">Java</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A"><span class="toc-number">2.</span> <span class="toc-text">注释</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%98%E8%A1%8C%E6%B3%A8%E9%87%8A"><span class="toc-number">2.1.</span> <span class="toc-text">単行注释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E8%A1%8C%E6%B3%A8%E9%87%8A"><span class="toc-number">2.2.</span> <span class="toc-text">多行注释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A"><span class="toc-number">2.3.</span> <span class="toc-text">文档注释</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.</span> <span class="toc-text">关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#class%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.1.</span> <span class="toc-text">class关键字</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">4.</span> <span class="toc-text">字面量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%B6%E8%A1%A8%E7%AC%A6"><span class="toc-number">4.1.</span> <span class="toc-text">制表符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%90%8D"><span class="toc-number">5.</span> <span class="toc-text">变量名</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">5.1.</span> <span class="toc-text">使用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">5.2.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.</span> <span class="toc-text">类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.1.</span> <span class="toc-text">基本类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.2.</span> <span class="toc-text">引用类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">7.</span> <span class="toc-text">标识符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5"><span class="toc-number">8.</span> <span class="toc-text">输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">9.</span> <span class="toc-text">运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E7%9B%B8%E5%8A%A0"><span class="toc-number">9.1.</span> <span class="toc-text">数值相加</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0"><span class="toc-number">9.2.</span> <span class="toc-text">字符串相加</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E7%9B%B8%E5%8A%A0"><span class="toc-number">9.3.</span> <span class="toc-text">字符相加</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%A2%9E%E3%80%81%E8%87%AA%E5%87%8F"><span class="toc-number">9.4.</span> <span class="toc-text">自增、自减</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">9.5.</span> <span class="toc-text">赋值运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">9.6.</span> <span class="toc-text">逻辑运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">9.7.</span> <span class="toc-text">三元运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">9.8.</span> <span class="toc-text">优先级</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5"><span class="toc-number">10.</span> <span class="toc-text">判断语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#if%E8%AF%AD%E5%8F%A5"><span class="toc-number">10.1.</span> <span class="toc-text">if语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#switch%E8%AF%AD%E5%8F%A5"><span class="toc-number">10.2.</span> <span class="toc-text">switch语句</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">11.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F"><span class="toc-number">11.1.</span> <span class="toc-text">定义方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">11.2.</span> <span class="toc-text">数组的初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%9C%B0%E5%9D%80%E5%80%BC"><span class="toc-number">11.3.</span> <span class="toc-text">数组的地址值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">11.4.</span> <span class="toc-text">数组的遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">11.5.</span> <span class="toc-text">java内存分配</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">12.</span> <span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">12.1.</span> <span class="toc-text">方法的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="toc-number">12.2.</span> <span class="toc-text">方法的格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-number">12.3.</span> <span class="toc-text">方法的重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">12.4.</span> <span class="toc-text">方法的基本数据型和引用数据类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">13.</span> <span class="toc-text">修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">14.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">14.1.</span> <span class="toc-text">类和对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%B1%BB%E3%80%81javaBean%E7%B1%BB%E5%92%8C%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">14.2.</span> <span class="toc-text">测试类、javaBean类和工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#JavaBean-%E7%B1%BB"><span class="toc-number">14.2.0.1.</span> <span class="toc-text">JavaBean 类</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%88Utility-Class%EF%BC%89"><span class="toc-number">14.2.0.2.</span> <span class="toc-text">工具类（Utility Class）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%BE%97%E5%88%B0%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">14.3.</span> <span class="toc-text">如何得到类的对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%B0%81%E8%A3%85"><span class="toc-number">14.4.</span> <span class="toc-text">类的封装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">14.5.</span> <span class="toc-text">this关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">14.6.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86JavaBean"><span class="toc-number">14.7.</span> <span class="toc-text">标准JavaBean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#static"><span class="toc-number">14.8.</span> <span class="toc-text">static</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1"><span class="toc-number">14.8.0.1.</span> <span class="toc-text">注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">14.9.</span> <span class="toc-text">类的继承</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">14.9.1.</span> <span class="toc-text">继承的特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%90%E7%B1%BB%E8%83%BD%E7%BB%A7%E6%89%BF%E7%88%B6%E7%B1%BB%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-number">14.9.2.</span> <span class="toc-text">子类能继承父类的内容</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E8%AE%BF%E9%97%AE%E7%89%B9%E7%82%B9"><span class="toc-number">14.9.3.</span> <span class="toc-text">成员变量和成员方法访问特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E8%AE%BF%E9%97%AE%E7%89%B9%E7%82%B9"><span class="toc-number">14.9.4.</span> <span class="toc-text">构造方法的访问特点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#this%E3%80%81super%E6%80%BB%E7%BB%93"><span class="toc-number">14.10.</span> <span class="toc-text">this、super总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%A4%9A%E6%80%81"><span class="toc-number">14.11.</span> <span class="toc-text">类的多态</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E8%B0%83%E7%94%A8%E6%88%90%E5%91%98%E7%89%B9%E7%82%B9"><span class="toc-number">14.11.1.</span> <span class="toc-text">多态调用成员特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E8%B0%83%E7%94%A8"><span class="toc-number">14.11.2.</span> <span class="toc-text">变量调用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="toc-number">14.11.3.</span> <span class="toc-text">方法调用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E4%BC%98%E5%8A%BF%E5%92%8C%E5%BC%8A%E7%AB%AF"><span class="toc-number">14.11.4.</span> <span class="toc-text">多态的优势和弊端</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%85%E5%92%8Cfinal"><span class="toc-number">14.12.</span> <span class="toc-text">包和final</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8C%85"><span class="toc-number">14.12.1.</span> <span class="toc-text">包</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%85%B6%E4%BB%96%E7%B1%BB%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-number">14.12.1.1.</span> <span class="toc-text">使用其他类的规则</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#final"><span class="toc-number">14.12.2.</span> <span class="toc-text">final</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">14.13.</span> <span class="toc-text">抽象类和抽象方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">14.13.1.</span> <span class="toc-text">抽象方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">14.13.2.</span> <span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">14.13.3.</span> <span class="toc-text">抽象类的使用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">14.14.</span> <span class="toc-text">接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F"><span class="toc-number">15.</span> <span class="toc-text">常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AF%E8%AF%AD"><span class="toc-number">16.</span> <span class="toc-text">术语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF"><span class="toc-number">17.</span> <span class="toc-text">接口继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="toc-number">18.</span> <span class="toc-text">继承关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#default%E6%96%B9%E6%B3%95"><span class="toc-number">19.</span> <span class="toc-text">default方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2-API"><span class="toc-number">20.</span> <span class="toc-text">字符串&amp;API</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#API"><span class="toc-number">20.0.1.</span> <span class="toc-text">API</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#String"><span class="toc-number">20.0.2.</span> <span class="toc-text">String</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">20.0.2.1.</span> <span class="toc-text">字符串的比较</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#StringBuilder"><span class="toc-number">20.0.2.2.</span> <span class="toc-text">StringBuilder</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#StringJoiner"><span class="toc-number">20.0.2.3.</span> <span class="toc-text">StringJoiner</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">21.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E9%9B%86%E5%90%88%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">21.0.1.</span> <span class="toc-text">创建集合的对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">22.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84"><span class="toc-number">22.1.</span> <span class="toc-text">什么是反射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96class%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">22.2.</span> <span class="toc-text">获取class对象的三种方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">22.3.</span> <span class="toc-text">获取构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">22.4.</span> <span class="toc-text">获取成员变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-number">22.5.</span> <span class="toc-text">获取成员方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">22.6.</span> <span class="toc-text">动态代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%B8%BAJava%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1"><span class="toc-number">22.7.</span> <span class="toc-text">如何为Java对象创建代理对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E6%B5%81"><span class="toc-number">23.</span> <span class="toc-text">IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IO%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">23.1.</span> <span class="toc-text">IO流的分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FileOutputStream"><span class="toc-number">23.2.</span> <span class="toc-text">FileOutputStream</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#FileOutputStream%E5%86%99%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">23.2.1.</span> <span class="toc-text">FileOutputStream写数据的三种方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8D%A2%E8%A1%8C%E5%86%99%E5%92%8C%E7%BB%AD%E5%86%99"><span class="toc-number">23.2.2.</span> <span class="toc-text">换行写和续写</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FileInputStream"><span class="toc-number">23.3.</span> <span class="toc-text">FileInputStream</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E8%BE%93%E5%85%A5%E6%B5%81%E5%BE%AA%E7%8E%AF%E8%AF%BB%E5%8F%96"><span class="toc-number">23.3.1.</span> <span class="toc-text">字节输入流循环读取</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D"><span class="toc-number">23.4.</span> <span class="toc-text">文件拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%BC%8A%E7%AB%AF%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">23.4.1.</span> <span class="toc-text">文件拷贝的弊端和解决方案</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#FileInputString%E4%B8%80%E6%AC%A1%E8%AF%BB%E5%A4%9A%E4%B8%AA%E5%AD%97%E8%8A%82"><span class="toc-number">23.4.2.</span> <span class="toc-text">FileInputString一次读多个字节</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO%E6%B5%81%E4%B8%8D%E5%90%8CJDK%E7%89%88%E6%9C%AC%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8"><span class="toc-number">23.5.</span> <span class="toc-text">IO流不同JDK版本捕获异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8%E8%A7%84%E5%88%99"><span class="toc-number">23.6.</span> <span class="toc-text">计算机存储规则</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#unicode%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="toc-number">23.6.1.</span> <span class="toc-text">unicode字符集</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%B9%B1%E7%A0%81"><span class="toc-number">23.6.2.</span> <span class="toc-text">为什么会出现乱码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E4%B8%AD%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">23.7.</span> <span class="toc-text">java中编码和解码的代码实现</span></a></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article" style="--smc-primary:#0078E7;"><link itemprop="mainEntityOfPage" href="https://kinseyy.github.io/2024/11/12/Java/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="kinsey"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="北歌"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Java<a class="post-edit-link" href="https://github.com/kinseyy/kinseyy.github.io/tree/master/2024/05/31/hello-world_posts/Java.md" target="_blank" title="Edit this post" rel="noopener"><span class="icon iconify" data-icon="ri:edit-line"></span></a></h1><div class="post-meta"><div class="post-time" style="display:block"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-line"></span></span> <time title="Created: 2024-11-12 18:49:38" itemprop="dateCreated datePublished" datetime="2024-11-12T18:49:38+08:00">2024-11-12</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-2-line"></span></span> <time title="Modified: 2025-04-17 21:39:51" itemprop="dateModified" datetime="2025-04-17T21:39:51+08:00">2025-04-17</time></div><span class="post-count"><span class="post-symbolcount"><span class="post-meta-item-icon" title="Word count in article"><span class="icon iconify" data-icon="ri:file-word-line"></span></span> <span title="Word count in article">10.7k</span><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="Reading time"><span class="icon iconify" data-icon="ri:timer-line"></span></span> <span title="Reading time">43m</span></span></span><span class="leancloud_visitors" id="/2024/11/12/Java/" data-flag-title="Java"><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="Views"><span class="icon iconify" data-icon="ri:eye-line"></span> <span class="leancloud-visitors-count"></span></span></span><span class="post-meta-divider">-</span><a href="#comment"><span class="post-meta-item-icon" title="Comments"><span class="icon iconify" data-icon="ri:chat-3-line"></span> <span class="waline-comment-count" id="/2024/11/12/Java/"></span></span></a><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><span class="icon iconify" data-icon="ri:folder-line"></span></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">学习笔记</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/java/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="tag-name">java</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body"><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><hr>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><h4 id="単行注释"><a href="#単行注释" class="headerlink" title="単行注释"></a>単行注释</h4><p>格式    &#x2F;&#x2F;注释信息</p>
<h4 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h4><p>格式    &#x2F;*注释信息*&#x2F;</p>
<h4 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h4><p>格式    &#x2F;**注释信息*&#x2F;</p>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p><img src="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202410142030404.png" alt="image-20241014203025134" loading="lazy"></p>
<h4 id="class关键字"><a href="#class关键字" class="headerlink" title="class关键字"></a>class关键字</h4><p>用于（创建&#x2F;定义）一个类，类是Java最基本的组成单元</p>
<h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p><img src="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202410142030688.png" alt="image-20241014203057613" loading="lazy"></p>
<h4 id="制表符"><a href="#制表符" class="headerlink" title="制表符"></a>制表符</h4><p>\t 在打印时，把前面字符串长度补齐到8或者8的整数倍，最少一个空格，最多8个空格</p>
<p><img src="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202410142034225.png" alt="image-20241014203401136" loading="lazy"></p>
<h3 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h3><p><strong>int</strong>  整数类型</p>
<p> **byte **</p>
<p><strong>short</strong></p>
<p><strong>long</strong>   定义时，数据值要加一个L作为后缀.可以大写也可以小写</p>
<p><strong>double</strong>  小数类型</p>
<p><strong>float</strong>   定义时，数据值要加一个F作为后缀</p>
<p><strong>char</strong> 字符类型</p>
<p><strong>String</strong>  字符串类型 注：S<strong>要大写</strong></p>
<p><strong>boolean</strong> 布尔类型</p>
<p><img src="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202410142048988.png" alt="image-20241014204822919" loading="lazy"></p>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p><img src="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202410142037126.png" alt="image-20241014203700067" loading="lazy"></p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>1.只能存一个值</p>
<p>2.变量名不允许重复定义</p>
<p>3.一条语句可以定义多个变量</p>
<p>int a&#x3D;1,b&#x3D;2,c&#x3D;3;</p>
<p>4.变量在使用之前要进行赋值</p>
<p>5.变量要注意作用域范围</p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>分为基本类型和引用类型</p>
<h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><p>基本类型是 Java 中最简单、最基本的数据类型，用于存储原始的数据值。它们直接存储数据，大小固定，并且没有附带任何方法或功能。</p>
<p>Java 有 8 种基本数据类型：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>大小</th>
<th>默认值</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>byte</code></td>
<td>1 字节</td>
<td>0</td>
<td><code>byte b = 10;</code></td>
</tr>
<tr>
<td><code>short</code></td>
<td>2 字节</td>
<td>0</td>
<td><code>short s = 100;</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td>4 字节</td>
<td>0</td>
<td><code>int i = 1000;</code></td>
</tr>
<tr>
<td><code>long</code></td>
<td>8 字节</td>
<td>0L</td>
<td><code>long l = 100000000L;</code></td>
</tr>
<tr>
<td><code>float</code></td>
<td>4 字节</td>
<td>0.0f</td>
<td><code>float f = 3.14f;</code></td>
</tr>
<tr>
<td><code>double</code></td>
<td>8 字节</td>
<td>0.0</td>
<td><code>double d = 3.14159;</code></td>
</tr>
<tr>
<td><code>char</code></td>
<td>2 字节</td>
<td>‘\u0000’</td>
<td><code>char c = &#39;A&#39;;</code></td>
</tr>
<tr>
<td><code>boolean</code></td>
<td>1 字节</td>
<td><code>false</code></td>
<td><code>boolean flag = true;</code></td>
</tr>
</tbody></table>
<ul>
<li><strong>数值类型</strong>：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>、<code>float</code>、<code>double</code>。</li>
<li><strong>字符类型</strong>：<code>char</code>。</li>
<li><strong>布尔类型</strong>：<code>boolean</code>。</li>
</ul>
<h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><p>引用类型的变量保存了对实际对象的引用（内存地址）。常见的引用类型包括类、数组和接口。</p>
<p>引用类型的例子：</p>
<ul>
<li><strong>类</strong>：如 <code>String</code>、<code>ArrayList</code>、<code>Person</code> 等</li>
<li><strong>数组</strong>：如 <code>int[]</code>、<code>String[]</code> 等</li>
<li><strong>接口</strong>：如 <code>List</code>、<code>Runnable</code> 等</li>
</ul>
<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p><img src="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202410142158637.png" alt="image-20241014215821487" loading="lazy"></p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>Scanner,这个类可以接受键盘输入的数字</p>
<p>导包，要写在类定义的上面</p>
<p><img src="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202410142200057.png" alt="image-20241014220038909" loading="lazy"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//1</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class hellow1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    //2</span><br><span class="line">       Scanner sc = new Scanner(System.in);</span><br><span class="line">       //3</span><br><span class="line">       int i=sc.nextInt();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="数值相加"><a href="#数值相加" class="headerlink" title="数值相加"></a>数值相加</h4><p><img src="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202410142217870.png" alt="image-20241014221741757" loading="lazy"></p>
<p>如果在计算时有小数参与，结果可能会不准确</p>
<p>算数语法跟c语言一样</p>
<p>数字进行运算时，数据类型不一样不能运算，需要转成一样的，才能运算</p>
<p><strong>隐式转换：</strong>取值范围小的数值–&gt;取值范围大的数值</p>
<p><strong>强制转换：</strong>取值范围大的数值–&gt;取值范围小的数值 </p>
<p><img src="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202410142224812.png" alt="image-20241014222431627" loading="lazy"></p>
<p><img src="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202410142225733.png" alt="image-20241014222543564" loading="lazy"></p>
<h4 id="字符串相加"><a href="#字符串相加" class="headerlink" title="字符串相加"></a>字符串相加</h4><p>字符串的“+”操作，跟python差不多</p>
<p><img src="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202410142228327.png" alt="image-20241014222811242" loading="lazy"></p>
<h4 id="字符相加"><a href="#字符相加" class="headerlink" title="字符相加"></a>字符相加</h4><p><img src="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202410142230328.png" alt="image-20241014223003209" loading="lazy"></p>
<h4 id="自增、自减"><a href="#自增、自减" class="headerlink" title="自增、自减"></a>自增、自减</h4><p>跟c差不多</p>
<p><img src="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202410142232844.png" alt="image-20241014223228739" loading="lazy"></p>
<h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><p>+&#x3D;、-&#x3D;、&#x2F;&#x3D;&#x3D;等等 ，跟c一样</p>
<h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>&amp;、 |、 ^ 、!</p>
<p>&amp;&amp;、||  当左边的表达式能确定最终的结果时，右边就不会参与运行了</p>
<h4 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h4><p>a?b:c 、; 跟c差不多</p>
<h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p><img src="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202410151427720.png" alt="image-20241015142719609" loading="lazy"></p>
<h3 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h3><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><p>跟c一样</p>
<h4 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h4><p><img src="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202410151431700.png" alt="image-20241015143106616" loading="lazy"></p>
<p>在jdk12时，可以使用 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">switch(a)</span><br><span class="line">case 值1-&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环语句</p>
<p>跟c一样有for，while，do…while</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="定义方式"><a href="#定义方式" class="headerlink" title="定义方式"></a>定义方式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">格式一</span><br><span class="line">数据类型 [] 数组名;</span><br><span class="line">//例如</span><br><span class="line">int [] array;</span><br><span class="line"></span><br><span class="line">格式二</span><br><span class="line">数据类型  数组名 [];</span><br><span class="line">//例如</span><br><span class="line">int array [];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>不同的数据类型对应不同的默认值</p>
<ul>
<li>整数类型：0</li>
<li>小数类型：0.0</li>
<li>布尔类型：false</li>
<li>字符类型：‘\u0000’</li>
<li>引用类型：null</li>
</ul>
<p><img src="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202411242052644.png" alt="image-20241124205246536" loading="lazy"></p>
<h4 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">格式一</span><br><span class="line">数据类型[] 数组名 = new 数据类型[]&#123;元素1，元素2，元素3，元素4...&#125;;</span><br><span class="line">//例如</span><br><span class="line">double[] arr = new double[]&#123;1.1,1.2,1.3&#125;;</span><br><span class="line"></span><br><span class="line">格式二</span><br><span class="line">数据类型[] 数组名 = &#123;元素1，元素2，元素3，元素4...&#125;;</span><br><span class="line">//例如</span><br><span class="line">int[] array = &#123;1,2,3,4,5&#125;;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>



<h4 id="数组的地址值"><a href="#数组的地址值" class="headerlink" title="数组的地址值"></a>数组的地址值</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int arr[]=&#123;1,2,3,4,5,6,7,8,9,10&#125;;</span><br><span class="line">System.out.println(arr);</span><br><span class="line"></span><br><span class="line">docker run -d \</span><br><span class="line">  --name java-chains \</span><br><span class="line">  --restart=always \</span><br><span class="line">  -p 8011:8011 \</span><br><span class="line">  -p 58080:58080 \</span><br><span class="line">  -p 50389:50389 \</span><br><span class="line">  -p 50388:50388 \</span><br><span class="line">  -p 3308:3308 \</span><br><span class="line">  -p 13999:13999 \</span><br><span class="line">  -p 50000:50000 \</span><br><span class="line">  -p 11527:11527 \</span><br><span class="line">  -e CHAINS_AUTH=true \</span><br><span class="line">  -e CHAINS_PASS=javajava \</span><br><span class="line">  javachains/javachains:1.4.0</span><br><span class="line">//打印的是第一个元素的地址值 [I@14ae5a5</span><br></pre></td></tr></table></figure>

<p>[I@14ae5a5</p>
<p>解读：</p>
<p>[   表示是数组.</p>
<p>i   表示是int类型</p>
<p>@ 表示一个间隔符号（固定格式）</p>
<p>14ae5a5 数组真正的地址值（十六进制）</p>
<p>通常把这个整体统称为地址</p>
<h4 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第一种 fro循环遍历</span><br><span class="line"><span class="type">int</span> arr[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//arr.length 获取数组长度</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">第二种</span><br><span class="line">arr.fori 自动生成</span><br><span class="line"></span><br><span class="line"> arr.fori ==&gt;  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;    </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">第三种  foreach语句遍历</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(type element: array)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> docker run -d \</span><br><span class="line">  --name java-chains \</span><br><span class="line">  --restart=always \</span><br><span class="line">  -p <span class="number">8011</span>:<span class="number">8011</span> \</span><br><span class="line">  -p <span class="number">58080</span>:<span class="number">58080</span> \</span><br><span class="line">  -p <span class="number">50389</span>:<span class="number">50389</span> \</span><br><span class="line">  -p <span class="number">50388</span>:<span class="number">50388</span> \</span><br><span class="line">  -p <span class="number">3308</span>:<span class="number">3308</span> \</span><br><span class="line">  -p <span class="number">13999</span>:<span class="number">13999</span> \</span><br><span class="line">  -p <span class="number">50000</span>:<span class="number">50000</span> \</span><br><span class="line">  -p <span class="number">11527</span>:<span class="number">11527</span> \</span><br><span class="line">  -e CHAINS_AUTH=<span class="literal">true</span> \</span><br><span class="line">  -e CHAINS_PASS= javajava\</span><br><span class="line">  javachains/javachains:<span class="number">1.4</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>



<p><img src="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202411242204255.png" alt="image-20241124220458160" loading="lazy"></p>
<h4 id="java内存分配"><a href="#java内存分配" class="headerlink" title="java内存分配"></a>java内存分配</h4><p>栈      方法运行时使用的内存，比如main方法运行，进入方法栈中执行</p>
<p>堆      存储对象或者数组，new来创建的，都存储在堆内存中</p>
<p>方法区  	存储可以运行的class文件</p>
<p>本地方法栈	JVM在使用操作系统功能的时候使用，和我们开发无关</p>
<p>寄存器 		给cpu使用   ，和我们开发无关</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h4><p>程序中最小的执行单元</p>
<h4 id="方法的格式"><a href="#方法的格式" class="headerlink" title="方法的格式"></a>方法的格式</h4><p><strong>最简单的格式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void 方法名()&#123;</span><br><span class="line">		方法体（就是打包起来的代码）</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">方法名();</span><br></pre></td></tr></table></figure>

<p><strong>带参数的格式</strong></p>
<p>有实参和形参的区别</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void 方法名(int num1, int num2)&#123;</span><br><span class="line"></span><br><span class="line">		方法体</span><br><span class="line">		System.out.println(num1+num2);</span><br><span class="line">		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>带返回值的格式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static 返回值类型 方法名(参数)&#123;</span><br><span class="line">		方法体</span><br><span class="line">		return 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h4><p>在同一个类中，定义了多个同名的方法，这些同名的方法具有同种的功能。</p>
<p>每个方法具有不同的参数类型或参数个数，这些同名的方法，就构成了重载关系</p>
<p><img src="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202411242237542.png" alt="image-20241124223719405" loading="lazy"></p>
<p>注意，一个变量不构成重载关系</p>
<h4 id="方法的基本数据型和引用数据类型"><a href="#方法的基本数据型和引用数据类型" class="headerlink" title="方法的基本数据型和引用数据类型"></a>方法的基本数据型和引用数据类型</h4><p><img src="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202411251911421.png" alt="image-20241125191132351" loading="lazy"></p>
<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>在 Java 中，<strong>修饰符</strong>（Modifiers）用于控制类、方法、变量的访问权限、行为以及其他特性。修饰符分为两大类：<strong>访问修饰符</strong> 和 <strong>非访问修饰符</strong>。修饰符提供了对类、方法、属性等的访问控制、功能增强以及其他特性管理。</p>
<p><strong>访问修饰符</strong></p>
<p>访问修饰符用于定义类、方法、变量的访问范围，即控制哪些类、方法、变量可以被访问。Java 提供了四种访问修饰符：</p>
<p><strong><code>public</code></strong></p>
<ul>
<li><strong>含义</strong>：表示该成员可以被任何其他类访问。</li>
<li><strong>适用范围</strong>：类、方法、变量。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line">    public int number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>private</code></strong></p>
<ul>
<li><strong>含义</strong>：表示该成员只能在定义它的类内部访问，不能在类外部访问。</li>
<li><strong>适用范围</strong>：方法、变量。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">    private int number;</span><br><span class="line">    </span><br><span class="line">    private void display() &#123;</span><br><span class="line">        System.out.println(number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>protected</code></strong></p>
<ul>
<li><strong>含义</strong>：表示该成员可以在同一包中的其他类访问，也可以在不同包中通过继承访问。</li>
<li><strong>适用范围</strong>：方法、变量。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">    protected int number;</span><br><span class="line">    </span><br><span class="line">    protected void display() &#123;</span><br><span class="line">        System.out.println(number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>默认</strong></p>
<ul>
<li><strong>含义</strong>：如果没有指定访问修饰符，默认是包私有，表示该成员仅能在同一包内的类中访问，包外不可访问。</li>
<li><strong>适用范围</strong>：方法、变量。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">    int number;  // 默认访问修饰符（包私有）</span><br><span class="line">    </span><br><span class="line">    void display() &#123;</span><br><span class="line">        System.out.println(number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h4><p><strong>类</strong>是一个模板或蓝图，用于创建对象。类定义了对象的<strong>属性</strong>（成员变量）和<strong>行为</strong>（方法）。它是对现实世界中的一类事物的抽象描述。</p>
<p>类的构成：</p>
<ul>
<li><strong>成员变量（属性）</strong>：表示对象的状态或特征。</li>
<li><strong>方法（行为）</strong>：表示对象可以执行的操作。</li>
</ul>
<p><strong>对象</strong>是类的一个实例。通过类定义的蓝图，我们可以创建多个对象，每个对象都有自己的属性值（状态）和可以执行的方法（行为）。对象在内存中有实际的存储空间，每个对象的属性是独立的。</p>
<p>创建对象：</p>
<p>创建对象的语法是使用 <code>new</code> 关键字，并调用类的构造方法（如果有定义）。</p>
<p><strong>在JAVA中必须先设计类，才能获得对象</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class 类名&#123;    </span><br><span class="line">    1.成员变量</span><br><span class="line">    2.成员方法</span><br><span class="line">    3.构造器</span><br><span class="line">    4.代码块</span><br><span class="line">    5.内部类</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Phone&#123;</span><br><span class="line">   //属性（成员变量）</span><br><span class="line">   String brand;</span><br><span class="line">   </span><br><span class="line">   //方法</span><br><span class="line">   public void call()&#123;</span><br><span class="line">   </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="测试类、javaBean类和工具类"><a href="#测试类、javaBean类和工具类" class="headerlink" title="测试类、javaBean类和工具类"></a>测试类、javaBean类和工具类</h4><ol>
<li>测试类（Test Class）</li>
</ol>
<p>测试类通常用于单元测试（Unit Testing）。它的目的是验证你的代码是否按预期工作。Java 中有一些常用的测试框架，如 JUnit、TestNG 等，它们帮助你创建和运行测试。</p>
<p><strong>特点：</strong></p>
<ul>
<li>包含测试方法，通常以 <code>@Test</code> 注解标注。</li>
<li>每个测试方法通常是独立的，验证特定功能或方法。</li>
<li>测试类不用于业务逻辑实现，而是用于验证程序的正确性。</li>
</ul>
<p><strong>例子：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import org.junit.jupiter.api.Test;</span><br><span class="line">import static org.junit.jupiter.api.Assertions.assertEquals;</span><br><span class="line"></span><br><span class="line">public class CalculatorTest &#123;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testAdd() &#123;</span><br><span class="line">        Calculator calculator = new Calculator();</span><br><span class="line">        int result = calculator.add(1, 2);</span><br><span class="line">        assertEquals(3, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，<code>CalculatorTest</code> 类是一个测试类，<code>testAdd()</code> 是一个测试方法，它验证 <code>Calculator</code> 类中的 <code>add()</code> 方法是否正确。</p>
<ol start="2">
<li><h6 id="JavaBean-类"><a href="#JavaBean-类" class="headerlink" title="JavaBean 类"></a>JavaBean 类</h6></li>
</ol>
<p>JavaBean 是一种符合特定规范的 Java 类，它通常用于数据封装。JavaBean 类的主要目的是通过提供一组 getter 和 setter 方法，使得它可以作为一个数据传输对象（DTO）在应用程序中传递数据。</p>
<p><strong>特点：</strong></p>
<ul>
<li>JavaBean 必须有一个无参构造函数。</li>
<li>类中的成员变量通常是私有的（<code>private</code>），通过公共的 getter 和 setter 方法访问。</li>
<li>它应该实现 <code>Serializable</code> 接口，以便可以进行序列化。</li>
<li>常用于数据库的实体映射或网络传输。</li>
</ul>
<p><strong>例子：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class User implements java.io.Serializable &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    // 无参构造函数</span><br><span class="line">    public User() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // getter 和 setter 方法</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>User</code> 类是一个 JavaBean 类，包含了私有成员变量 <code>name</code> 和 <code>age</code>，以及它们的 getter 和 setter 方法。这个类符合 JavaBean 的规范，通常用于传递用户信息。</p>
<ol start="3">
<li><h6 id="工具类（Utility-Class）"><a href="#工具类（Utility-Class）" class="headerlink" title="工具类（Utility Class）"></a>工具类（Utility Class）</h6></li>
</ol>
<p>工具类是一个包含一组静态方法的类，这些方法提供常用的功能，通常与某些操作或计算相关。工具类中的方法通常是通用的，因此可以在应用程序的不同部分重复使用。工具类通常只包含静态方法，并且不需要实例化。</p>
<p><strong>特点：</strong></p>
<ul>
<li>工具类通常只包含静态方法，方便调用。</li>
<li>通常不需要实例化对象。</li>
<li>可以包含各种实用功能，如字符串处理、日期处理、数学计算等。</li>
</ul>
<p><strong>例子：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class StringUtils &#123;</span><br><span class="line"></span><br><span class="line">    // 判断字符串是否为空</span><br><span class="line">    public static boolean isEmpty(String str) &#123;</span><br><span class="line">        return str == null || str.trim().isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 字符串反转</span><br><span class="line">    public static String reverse(String str) &#123;</span><br><span class="line">        if (str == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        return new StringBuilder(str).reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的 <code>StringUtils</code> 类中，<code>isEmpty()</code> 和 <code>reverse()</code> 方法是工具方法。你可以直接调用这些静态方法而不需要创建 <code>StringUtils</code> 的实例。</p>
<p>主要区别总结：</p>
<ul>
<li><strong>测试类</strong>：用于测试应用程序的代码是否按预期工作，通常包含测试框架（如 JUnit）的测试方法。</li>
<li><strong>JavaBean 类</strong>：用于封装数据，通常包含私有字段和公共的 getter&#x2F;setter 方法，符合 JavaBean 的规范。</li>
<li><strong>工具类</strong>：包含常用的静态方法，用于实现通用功能（如字符串处理、文件操作等），通常不需要实例化。</li>
</ul>
<h4 id="如何得到类的对象"><a href="#如何得到类的对象" class="headerlink" title="如何得到类的对象"></a>如何得到类的对象</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类名 对象名=new 类名();</span><br><span class="line"></span><br><span class="line">Phone p =new Phone();</span><br></pre></td></tr></table></figure>



<h4 id="类的封装"><a href="#类的封装" class="headerlink" title="类的封装"></a>类的封装</h4><p>对象代表什么，就得封装对应的数据，并提供数据对应的行为</p>
<p>封装通常通过设置<strong>私有属性</strong>和<strong>公共方法</strong>来实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// 私有属性，外部无法直接访问</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公共的 getter 和 setter 方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="comment">// 在 setter 方法中可以加入一些控制逻辑，确保数据合法</span></span><br><span class="line">        <span class="keyword">if</span> (age &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Age must be positive.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公共方法，类的行为</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">introduce</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hi, my name is &quot;</span> + name + <span class="string">&quot; and I am &quot;</span> + age + <span class="string">&quot; years old.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用 setter 方法设置属性</span></span><br><span class="line">        person.setName(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">        person.setAge(<span class="number">25</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用 getter 方法获取属性值</span></span><br><span class="line">        System.out.println(person.getName()); <span class="comment">// 输出：Alice</span></span><br><span class="line">        System.out.println(person.getAge());  <span class="comment">// 输出：25</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用公共方法</span></span><br><span class="line">        person.introduce(); <span class="comment">// 输出：Hi, my name is Alice and I am 25 years old.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h4><p>  this用来调用成员变量，区分成员变量和局部变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Phone&#123;</span><br><span class="line">   //属性（成员变量）</span><br><span class="line">   int age=20;</span><br><span class="line">   </span><br><span class="line">   //方法</span><br><span class="line">   public void call()&#123;</span><br><span class="line">   </span><br><span class="line">   int age=10;</span><br><span class="line">    System.out.println(brand); //输出10</span><br><span class="line">   System.out.println(this.brand); //输出20</span><br><span class="line">   </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>作用：在创建对象的时候给成员变量进行赋值</p>
<p><strong>无参</strong>数构造方法：	初始化的对象时，成员变量的数据均采用默认值，</p>
<p><strong>有参</strong>数构造方法:		在初始化对象的时候，同时可以为对象进行赋值。</p>
<p><strong>形式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Student&#123;</span><br><span class="line">	</span><br><span class="line">	修饰符 类名(参数)&#123;</span><br><span class="line">	方法体</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特点：</strong></p>
<p>1.方法名与类名相同，大小写也要一致</p>
<p>2.没有返回类型，连void也没有</p>
<p>3.没有具体的返回值(不能由retrun带回结果数据)</p>
<p><strong>执行时机:</strong></p>
<p>1.创建对象的时候由虚拟机调用，不能手动调用构造方法</p>
<p>2.每创建一次对象，就会调用一次构造方法</p>
<p><strong>注意事项</strong></p>
<p>① 构造方法的定义</p>
<p>如果没有定义构造方法，系统将给出一个默认的无参数构造方法</p>
<p>如果定义了构造方法，系统将不再提供默认的构造方法</p>
<p>② 构造方法的重载</p>
<p>带参构造方法，和无参数构造方法，两者方法名相同，但是参数不同，这叫做构造方法的重载</p>
<p>③ 推荐的使用方式</p>
<p>无论是否使用，都手动书写无参数构造方法，和带全部参数的构造方法</p>
<h4 id="标准JavaBean"><a href="#标准JavaBean" class="headerlink" title="标准JavaBean"></a>标准JavaBean</h4><ol>
<li>类名需要见名知意</li>
<li>成员变量使用private修饰</li>
<li>提供至少两个构造方法<ol>
<li>无参构造方法</li>
<li>带全部参数的构造方法</li>
</ol>
</li>
<li>成员方法<br>提供每一个成员变量对应的setXxx()&#x2F;getXxx()<br>如果还有其他行为，也需要写上</li>
</ol>
<p><img src="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202411252210243.png" alt="image-20241125221012155" loading="lazy"></p>
<h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><p>static表示静态，是Java中的一个修饰符，可以修饰成员方法和成员变量</p>
<p>被static修饰的成员变量叫做<strong>静态变量</strong>(类变量)</p>
<p><img src="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202411252231802.png" alt="image-20241125223150756" loading="lazy"></p>
<p>被static修饰的成员方法，叫做<strong>静态方法</strong></p>
<p><img src="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202411261447025.png" alt="image-20241126144657919" loading="lazy"></p>
<h6 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h6><p><img src="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202411261503699.png" alt="image-20241126150304641" loading="lazy"></p>
<h4 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h4><p>Java中提供一个关键字extends，用这个关键字，我们可以让一个类和你应该类建立起继承关系</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Student extends Person &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>student成为子类(派生类)，Person成为父类(基类或超类)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 父类</span><br><span class="line">class Animal &#123;</span><br><span class="line">    void speak() &#123;</span><br><span class="line">        System.out.println(&quot;Animal speaks&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 子类</span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">    // 子类重写父类方法</span><br><span class="line">    @Override</span><br><span class="line">    void speak() &#123;</span><br><span class="line">        System.out.println(&quot;Dog barks&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Dog dog = new Dog();</span><br><span class="line">        dog.speak();  // 输出：Dog barks</span><br><span class="line">        </span><br><span class="line">        Animal animal = new Animal();</span><br><span class="line">        animal.speak();  // 输出：Animal speaks</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>使用继承的好处</strong></p>
<p>可以把多个子类中重复的代码抽取到父类中了，提高代码的复用性</p>
<p>子类可以在父类的基础上，增加其他的功能，使子类更强大，</p>
<p><strong>使用条件</strong></p>
<p>当类与类之间，存在相同(共性)的内容，并满足子类是父类的一种，就可以考虑使用继承，来优化代码</p>
<h5 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h5><p> Java只支持但继承，不支持多继承，但支持多层继承</p>
<p>多层继承：子类A可以继承父类B，父类B可以继承父类C  </p>
<p>每一个类都直接或者间接的继承于Object</p>
<h5 id="子类能继承父类的内容"><a href="#子类能继承父类的内容" class="headerlink" title="子类能继承父类的内容"></a>子类能继承父类的内容</h5><p><img src="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202411261558114.png" alt="image-20241126155824043" loading="lazy"></p>
<h5 id="成员变量和成员方法访问特点"><a href="#成员变量和成员方法访问特点" class="headerlink" title="成员变量和成员方法访问特点"></a>成员变量和成员方法访问特点</h5><p> 遵循就近原则：谁离我近，我就用谁</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Parent &#123;</span><br><span class="line">    int x = 10;  // 父类成员变量</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Parent &#123;</span><br><span class="line">    int x = 20;  // 子类成员变量</span><br><span class="line">    void printX() &#123;</span><br><span class="line">        System.out.println(x);  // 访问子类的x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Child child = new Child();</span><br><span class="line">        child.printX();  // 输出：20</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果出现了重名变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Parent &#123;</span><br><span class="line">    int x = 10;  // 父类的变量</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Parent &#123;</span><br><span class="line">    int x = 20;  // 子类的变量，遮蔽父类的同名变量</span><br><span class="line"></span><br><span class="line">    void printX() &#123;</span><br><span class="line">        System.out.println(x);  // 从局部变量找</span><br><span class="line">        System.out.println(this.x); //从子类找</span><br><span class="line">        System.out.println(super.x);  // 访问的是父类的x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Child child = new Child();</span><br><span class="line">        child.printX();  // 输出：20 20  10 </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>方法重写注意事项和要求</p>
<p><img src="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202411261625965.png" alt="image-20241126162508846" loading="lazy"></p>
<p>注意：子类中重写的方法上面要加上@override</p>
<h5 id="构造方法的访问特点"><a href="#构造方法的访问特点" class="headerlink" title="构造方法的访问特点"></a>构造方法的访问特点</h5><p><strong>继承中：构造方法的访问特点</strong></p>
<p>父类中的构造方法不会被子类继承。</p>
<p>子类中所有的构造方法默认先访问父类中的无参构造，再执行自己</p>
<p><strong>为什么?</strong></p>
<p>子类在初始化的时候，有可能会使用到父类中的数据，如果父类没有完成初始化，子类将无法使用父类的数据</p>
<p>子类初始化之前，一定要调用父类构造方法先完成父类数据空间的初始化。</p>
<p>使用this()访问本类的构造方法</p>
<p>使用super访问父类的构造方法</p>
<h4 id="this、super总结"><a href="#this、super总结" class="headerlink" title="this、super总结"></a>this、super总结</h4><p>this  ： 理解为一个变量，表示当前方法调用者的地址值</p>
<p>super: 代表父类存储空间</p>
<p><img src="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202411261645171.png" alt="image-20241126164556106" loading="lazy"></p>
<h4 id="类的多态"><a href="#类的多态" class="headerlink" title="类的多态"></a>类的多态</h4><p>对象代表什么，就得封装对应的数据，并提供数据对应的行为</p>
<p><strong>定义</strong></p>
<p>同类型的对象，表现出不同形态</p>
<p><strong>多态表现形式</strong></p>
<p>父类类型 对象名称 &#x3D; 子类对象</p>
<p><strong>多态的前提</strong></p>
<ol>
<li>有继承关系</li>
<li>有父引用指向子类对象</li>
<li>有方法重写</li>
</ol>
<h5 id="多态调用成员特点"><a href="#多态调用成员特点" class="headerlink" title="多态调用成员特点"></a>多态调用成员特点</h5><p>变量调用：编译看左边，运行也看左边</p>
<p>方法调用：编译看左边，运行看右边</p>
<h5 id="变量调用"><a href="#变量调用" class="headerlink" title="变量调用"></a>变量调用</h5><p><strong>编译看左边</strong>:javac编译代码的时候，会看左边的父类中有没有这个变量，如果有，编译成功，如果没有编译失败。</p>
<p>在Java中，<strong>编译时</strong>的行为是由引用变量的类型（也就是“左边”）决定的。Java编译器在编译代码时，确定方法调用或成员访问是根据引用类型来进行检查的。因此，编译时检查的是引用变量所声明的类型，而不是它实际指向的对象类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Parent &#123;</span><br><span class="line">    int x = 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Parent &#123;</span><br><span class="line">    int x = 20;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Parent obj = new Child();</span><br><span class="line">        System.out.println(obj.x); // 编译错误 实际上会访问 Parent的x的值</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编译时</strong>：在上面的代码中，<code>obj</code>是<code>Parent</code>类型的引用，而不是<code>Child</code>类型。因此，编译器会检查<code>Parent</code>类中是否有名为<code>x</code>的变量，虽然<code>obj</code>在运行时指向<code>Child</code>对象，但编译器只会检查<code>Parent</code>类中的<code>x</code>，因此无法找到<code>x</code>变量，编译器会报错。如果我们使用<code>obj.x</code>，编译器就无法知道它是否在<code>Child</code>类中有<code>x</code>字段，它只会根据<code>Parent</code>类的声明进行检查。</p>
<p><strong>运行也看左边</strong>:java运行代码的时候，实际获取的就是左边父类中成员变量的值</p>
<p>在<strong>运行时</strong>，Java会根据实际对象的类型来决定使用哪个成员变量或方法。这是Java中<strong>动态绑定</strong>的特性（尤其是方法的动态绑定）。对于成员变量（尤其是实例变量），它会选择实际对象中的值，即使引用类型是父类类型，也会访问实际对象中（子类）的成员变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Parent &#123;</span><br><span class="line">    int x = 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Parent &#123;</span><br><span class="line">    int x = 20;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Parent obj = new Child();  // 父类引用指向子类对象</span><br><span class="line">        System.out.println(obj.x);  // 输出：10</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行时</strong>：虽然<code>obj</code>是<code>Parent</code>类型的引用，但它指向的是<code>Child</code>类型的对象。<code>obj.x</code>访问的是<code>Parent</code>类中的<code>x</code>变量，因为编译器在编译时是根据<code>obj</code>的声明类型<code>Parent</code>来查找成员变量的，而不是<code>Child</code>类的成员变量。</p>
<h5 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    void sound() &#123;</span><br><span class="line">        System.out.println(&quot;Animal makes a sound&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">    @Override</span><br><span class="line">    void sound() &#123;</span><br><span class="line">        System.out.println(&quot;Dog barks&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Animal obj = new Dog();  // 父类引用指向子类对象</span><br><span class="line">        obj.sound();  // 运行时调用Dog类的sound()方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>编译时看左边：</strong></li>
</ol>
<ul>
<li>在编译时，<code>obj</code>的引用类型是<code>Animal</code>，所以编译器会检查<code>Animal</code>类中是否有<code>sound()</code>方法。</li>
<li>编译器会发现<code>Animal</code>类有<code>sound()</code>方法，因此不会报编译错误。</li>
</ul>
<ol start="2">
<li><strong>运行时看右边：</strong></li>
</ol>
<ul>
<li>运行时，<code>obj</code>指向的是<code>Dog</code>类的对象。因此，Java会根据实际对象的类型（<code>Dog</code>）来调用重写后的<code>Dog</code>类中的<code>sound()</code>方法。</li>
<li>尽管引用类型是<code>Animal</code>，运行时仍然会调用子类<code>Dog</code>的<code>sound()</code>方法，输出的是<code>Dog barks</code>，而不是<code>Animal makes a sound</code>。</li>
</ul>
<h5 id="多态的优势和弊端"><a href="#多态的优势和弊端" class="headerlink" title="多态的优势和弊端"></a>多态的优势和弊端</h5><p><img src="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202411261950890.png" alt="image-20241126195058762" loading="lazy"></p>
<h4 id="包和final"><a href="#包和final" class="headerlink" title="包和final"></a>包和final</h4><h5 id="包"><a href="#包" class="headerlink" title="包"></a>包</h5><p>包就是文件夹。用来管理各种不同功能的Java类，方便后期维护</p>
<p>包名通常基于公司或项目的域名（反向域名命名法），以减少与其他组织或项目的包名冲突。</p>
<p>例如，如果你的公司网站是 <code>example.com</code>，那么包名的前缀应是 <code>com.example.包的作用</code>。</p>
<h6 id="使用其他类的规则"><a href="#使用其他类的规则" class="headerlink" title="使用其他类的规则"></a>使用其他类的规则</h6><p>使用其他类时，需要使用全类名（com.example.包的作用.类名）</p>
<p><img src="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202502181547149.png" alt="image-20250218154739059" loading="lazy"></p>
<ul>
<li>使用同一个包中的类时，不需要导包</li>
<li>使用java.lang包中的类时，不需要导包</li>
<li>其他情况都需要导包</li>
<li>如果同时使用两个包中的同名类，需要使用全类名</li>
</ul>
<h5 id="final"><a href="#final" class="headerlink" title="final"></a>final</h5><p>可以修饰方法、类、变量</p>
<p>final 方法：表明该方法是最终方法，不能被重写</p>
<p>final 类 ：表明该类是最终类，不能被继承</p>
<p>final 变量：叫做常量，只能被赋值一次</p>
<h4 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h4><p>类用于描述现实生活中一类事物。类中有属性、方法等成员。</p>
<p>父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。那么父类的方法声明和方法主体，只有声明还有 意义，而方法主体则没有存在的意义了。</p>
<p>某种情况下，父类只能知道子类应该具备一个怎样的方法，但是不能够明确知道如何实现该方法。只能在子类中才能确定如何去实现方法体。例如：所有几何图形都应该具备一个计算面积的方法。但是不同的几何图形计算面积的方式不同。</p>
<p>我们把没有方法主体的方法称为<strong>抽象方法</strong>。Java语法规定，包含抽象方法 的类就是<strong>抽象类</strong>。</p>
<h5 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h5><p><strong>抽象方法</strong> ： 只有方法的声明，没有方法体，以分号 ; 结尾，使用 <code>abstract</code> 关键字修饰</p>
<p>定义格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">abstract</span> 返回值类型 方法名(参数列表);</span><br></pre></td></tr></table></figure>

<p>代码举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>抽象方法不能用private、final、static、native修饰</p>
</blockquote>
<h5 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a><strong>抽象类</strong></h5><p><strong>抽象类</strong>：包含抽象方法的类。如果一个类包含抽象方法，那么该类必须是抽象类，使用 <code>abstract</code> 关键字修饰</p>
<p>定义格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> class 类名 &#123;</span><br><span class="line">    <span class="comment">//抽象类中可以包含变量、常量，抽象方法，非抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="抽象类的使用"><a href="#抽象类的使用" class="headerlink" title="抽象类的使用"></a><strong>抽象类的使用</strong></h5><p>抽象类不能实例化，不能直接创建对象。抽象类是用来被继承的，继承抽象类的子类<strong>必须重写父类所有的抽象方法</strong>。否则，该子类也必须声明为抽象类，使用 <code>abstract</code> 关键字修饰</p>
<p>抽象类也是类，因此原来类中可以有的成员，抽象类都可以有，那么抽象类不能直接创建对象，为什么还有构造器呢？供子类调用，子类创建对象时，需要为从父类继承的属性初始化。</p>
<p>抽象类不能使用final修饰</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">      	System.out.println(<span class="string">&quot;讲课&quot;</span>); 	 </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Abstract</span> ClassTest &#123;</span><br><span class="line"> 	 <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建子类对象</span></span><br><span class="line">        <span class="type">Teacher</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>(); </span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 调用run方法</span></span><br><span class="line">        t.work();</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">讲课</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此时的方法重写，是对子类对父类抽象方法的完成实现，我们将这种方法重写的操作，叫做实现方法</p>
<p>实现：去掉abstract关键字，加上方法体{…}</p>
<p><strong>抽象类注意事项</strong>：</p>
<ol>
<li><p>抽象类<strong>不能创建对象</strong>，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。</p>
<blockquote>
<p>理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。</p>
</blockquote>
</li>
<li><p>抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。</p>
<blockquote>
<p>理解：子类的构造方法中，有默认的super()，需要访问父类构造方法。</p>
</blockquote>
</li>
<li><p>抽象类中，可以有成员变量。</p>
<blockquote>
<p>理解：子类的共性的成员变量 , 可以定义在抽象父类中。</p>
</blockquote>
</li>
<li><p>抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</p>
<blockquote>
<p>理解：未包含抽象方法的抽象类，声明为抽象类目的就是不想让使用者创建该类的对象，通常用于某些特殊的类结构设计。</p>
</blockquote>
</li>
<li><p>抽象类的子类，必须重写抽象父类中<strong>所有的</strong>抽象方法，否则，编译报错。除非该子类也是抽象类。</p>
<blockquote>
<p>理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。</p>
</blockquote>
</li>
</ol>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>在抽象类中，抽象方法本质上是定义接口规范：即规定高层类的接口，从而保证所有子类都有相同的接口实现，这样，多态就能发挥出威力。</p>
<p>如果一个抽象类没有字段，所有方法全部都是抽象方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就可以把该抽象类改写为接口：<code>interface</code>。</p>
<p>在Java中，使用<code>interface</code>可以声明一个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所谓<code>interface</code>，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是<code>public abstract</code>的，所以这两个修饰符不需要写出来（写不写效果都一样）。</p>
<p>当一个具体的<code>class</code>去实现一个<code>interface</code>时，需要使用<code>implements</code>关键字。举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name + <span class="string">&quot; run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道，在Java中，一个类只能继承自另一个类，不能从多个类继承。但是，一个类可以实现多个<code>interface</code>，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span>, Hello &#123; <span class="comment">// 实现了两个interface</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量一般作为系统的配置信息，方便维护，提高可读性</p>
<p>常量的命名规范：</p>
<p>単个单词：全部大写</p>
<p>多个单词：全部大写，单词之间用下划线隔开</p>
<p><strong>注意：</strong></p>
<p>final修饰的变量是基本类型：那么变量存储的数据值不能发生改变</p>
<p>final修饰的变量是引用类型：那么变量存储的地址值不能发生改变，对象内部可以改变</p>
<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p>注意区分术语：</p>
<p>Java的接口特指<code>interface</code>的定义，表示一个接口类型和一组方法签名，而编程接口泛指接口规范，如方法签名，数据格式，网络协议等。</p>
<p>抽象类和接口的对比如下：</p>
<table>
<thead>
<tr>
<th></th>
<th align="left">abstract class</th>
<th align="left">interface</th>
</tr>
</thead>
<tbody><tr>
<td>继承</td>
<td align="left">只能extends一个class</td>
<td align="left">可以implements多个interface</td>
</tr>
<tr>
<td>字段</td>
<td align="left">可以定义实例字段</td>
<td align="left">不能定义实例字段</td>
</tr>
<tr>
<td>抽象方法</td>
<td align="left">可以定义抽象方法</td>
<td align="left">可以定义抽象方法</td>
</tr>
<tr>
<td>非抽象方法</td>
<td align="left">可以定义非抽象方法</td>
<td align="left">可以定义default方法</td>
</tr>
</tbody></table>
<h3 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h3><p>一个<code>interface</code>可以继承自另一个<code>interface</code>。<code>interface</code>继承自<code>interface</code>使用<code>extends</code>，它相当于扩展了接口的方法。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，<code>Person</code>接口继承自<code>Hello</code>接口，因此，<code>Person</code>接口现在实际上有3个抽象方法签名，其中一个来自继承的<code>Hello</code>接口。</p>
<h3 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h3><p>合理设计<code>interface</code>和<code>abstract class</code>的继承关系，可以充分复用代码。一般来说，公共逻辑适合放在<code>abstract class</code>中，具体逻辑放到各个子类，而接口层次代表抽象程度。可以参考Java的集合类定义的一组接口、抽象类以及具体子类的继承关系：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────┐</span><br><span class="line">│   Iterable    │</span><br><span class="line">└───────────────┘</span><br><span class="line">        ▲                ┌───────────────────┐</span><br><span class="line">        │                │      Object       │</span><br><span class="line">┌───────────────┐        └───────────────────┘</span><br><span class="line">│  Collection   │                  ▲</span><br><span class="line">└───────────────┘                  │</span><br><span class="line">        ▲     ▲          ┌───────────────────┐</span><br><span class="line">        │     └──────────│AbstractCollection │</span><br><span class="line">┌───────────────┐        └───────────────────┘</span><br><span class="line">│     List      │                  ▲</span><br><span class="line">└───────────────┘                  │</span><br><span class="line">              ▲          ┌───────────────────┐</span><br><span class="line">              └──────────│   AbstractList    │</span><br><span class="line">                         └───────────────────┘</span><br><span class="line">                                ▲     ▲</span><br><span class="line">                                │     │</span><br><span class="line">                                │     │</span><br><span class="line">                     ┌────────────┐ ┌────────────┐</span><br><span class="line">                     │ ArrayList  │ │ LinkedList │</span><br><span class="line">                     └────────────┘ └────────────┘</span><br></pre></td></tr></table></figure>

<p>在使用的时候，实例化的对象永远只能是某个具体的子类，但总是通过接口去引用它，因为接口比抽象类更抽象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(); <span class="comment">// 用List接口引用具体子类的实例</span></span><br><span class="line"><span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> list; <span class="comment">// 向上转型为Collection接口</span></span><br><span class="line"><span class="type">Iterable</span> <span class="variable">it</span> <span class="operator">=</span> coll; <span class="comment">// 向上转型为Iterable接口</span></span><br></pre></td></tr></table></figure>

<h3 id="default方法"><a href="#default方法" class="headerlink" title="default方法"></a>default方法</h3><p>在接口中，可以定义<code>default</code>方法。例如，把<code>Person</code>接口的<code>run()</code>方法改为<code>default</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Xiao Ming&quot;</span>);</span><br><span class="line">        p.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot; run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现类可以不必覆写<code>default</code>方法。<code>default</code>方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是<code>default</code>方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。</p>
<p><code>default</code>方法和抽象类的普通方法是有所不同的。因为<code>interface</code>没有字段，<code>default</code>方法无法访问字段，而抽象类的普通方法可以访问实例字段。</p>
<h3 id="字符串-API"><a href="#字符串-API" class="headerlink" title="字符串&amp;API"></a>字符串&amp;API</h3><h5 id="API"><a href="#API" class="headerlink" title="API"></a>API</h5><p>简单理解:API就是别人已经写好的东西，我们不需要自己编写，直接使用即可</p>
<p>可通过API帮助文档查找需要的API</p>
<h5 id="String"><a href="#String" class="headerlink" title="String"></a>String</h5><p>java.lang.String 类代表字符串，Java 程序中的所有字符串文字(例如“abc”)都为此类的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String name =&quot;小面&quot;;</span><br></pre></td></tr></table></figure>

<p>用+可以拼接</p>
<p><img src="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202411252031928.png" alt="image-20241125203147721" loading="lazy"></p>
<h6 id="字符串的比较"><a href="#字符串的比较" class="headerlink" title="字符串的比较"></a>字符串的比较</h6><p><img src="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202411252034486.png" alt="image-20241125203433405" loading="lazy"></p>
<p><strong>方法</strong>(一般用这个)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string1.equals(string2)  完全一样才是true，否则为false</span><br><span class="line"></span><br><span class="line">string1.equalsIgnoreCase(string1,string2)   比较时忽略大小写</span><br></pre></td></tr></table></figure>



<h6 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h6><p>StringBuilder 可以看成是一个容器，创建之后里面的内容是可变的</p>
<p>作用：提高字符串的操作效率</p>
<p>它与<code>String</code>的主要区别在于，<code>String</code>对象是不可变的，每次对<code>String</code>进行修改都会生成新的字符串对象；而<code>StringBuilder</code>可以直接在原对象上修改内容，避免创建新的对象，从而提高效率。</p>
<p><strong>构造方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder aa = new StringBuilder(&quot;abc&quot;);  将abc放入StringBuilder对象里</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>常用操作</strong></p>
<p>append()  添加数据，并返回对象本身</p>
<p>reverse()   翻转容器中的内容</p>
<p>length()	返回长度</p>
<p>toString() 实现吧StringBuilder转换为String</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder aa = new StringBuilder();  </span><br><span class="line">aa.append(&quot;123&quot;); //123</span><br><span class="line">aa.reverse();   //321</span><br><span class="line">aa.length();   //3</span><br><span class="line">aa.tostring()  // 变成字符串</span><br></pre></td></tr></table></figure>

<h6 id="StringJoiner"><a href="#StringJoiner" class="headerlink" title="StringJoiner"></a>StringJoiner</h6><p>Stringloiner跟StringBuilder一样，也可以看成是一个容器，创建之后里面的内容是可变的。</p>
<p>通常用于将多个字符串以指定分隔符连接成一个单一的字符串</p>
<p>作用:提高字符串的操作效率，而且代码编写特别简洁，但是目前市场上很少有人用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">StringJoiner(&quot;间隔符&quot;, &quot;开始符号&quot;, &quot;结束符号&quot;);</span><br><span class="line"></span><br><span class="line">import java.util.StringJoiner;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        StringJoiner joiner = new StringJoiner(&quot;, &quot;, &quot;[&quot;, &quot;]&quot;);</span><br><span class="line">        joiner.add(&quot;apple&quot;);</span><br><span class="line">        joiner.add(&quot;banana&quot;);</span><br><span class="line">        joiner.add(&quot;cherry&quot;);</span><br><span class="line">        </span><br><span class="line">        System.out.println(joiner.toString());  // 输出: [apple, banana, cherry]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>常用操作</strong></p>
<p>add()</p>
<p>length()</p>
<p>toString()</p>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>集合中可以存引用数据类型和基本数据类型，但存放基本数据类型时，要使用对应的包装类</p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>Boolean</code></td>
</tr>
<tr>
<td><code>byte</code></td>
<td><code>Byte</code></td>
</tr>
<tr>
<td><code>char</code></td>
<td><code>Character</code></td>
</tr>
<tr>
<td><code>short</code></td>
<td><code>Short</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>Integer</code></td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>Long</code></td>
</tr>
<tr>
<td><code>float</code></td>
<td><code>Float</code></td>
</tr>
<tr>
<td><code>double</code></td>
<td><code>Double</code></td>
</tr>
</tbody></table>
<p><strong>与数组的区别</strong></p>
<p><strong>数组</strong>：数组的大小是固定的，一旦定义，就无法更改。在创建数组时，必须指定其长度，并且一旦数组创建完成，大小就不能再修改。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int[] arr = new int[5];  // 创建一个包含 5 个元素的数组</span><br></pre></td></tr></table></figure>

<p><strong>集合</strong>：集合的大小是动态的，可以根据需要自动增长或缩小。例如，<code>ArrayList</code> 可以根据添加或删除元素自动调整大小。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(10);</span><br><span class="line">list.add(20);</span><br></pre></td></tr></table></figure>



<h5 id="创建集合的对象"><a href="#创建集合的对象" class="headerlink" title="创建集合的对象"></a><strong>创建集合的对象</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">泛型：限定集合中存储数据的类型</span><br><span class="line">ArrayList&lt;包装类&gt; list = new ArrayList&lt;&gt;();  只能存储这种包装类的  //在JDK7以上使用</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>成员方法</strong></p>
<p><img src="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202411252127044.png" alt="image-20241125212751941" loading="lazy"></p>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><h4 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h4><p>反射允许对封装类的字段，方法和构造函数的信息进行编程访问</p>
<p><img src="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202502181646735.png" alt="image-20250218164622512" loading="lazy"></p>
<h4 id="获取class对象的三种方式"><a href="#获取class对象的三种方式" class="headerlink" title="获取class对象的三种方式"></a>获取class对象的三种方式</h4><p>1.Class.forName(全类名)  最为常用的</p>
<p>2.类名.class  当做参数进行传递</p>
<p>3.对象.getClass();</p>
<p><img src="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202502181657494.png" alt="image-20250218165756402" loading="lazy"></p>
<h4 id="获取构造方法"><a href="#获取构造方法" class="headerlink" title="获取构造方法"></a>获取构造方法</h4><p><img src="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202502181701119.png" alt="image-20250218170101029" loading="lazy"></p>
<p>先获取class对象，再获取构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class clazz=Class.forName(<span class="string">&quot;全类名&quot;</span>);</span><br><span class="line">Constructor[] cons1=clazz.getConstructors();</span><br><span class="line"><span class="keyword">for</span>(Constructor con:cons2)&#123;</span><br><span class="line">System.out.println(con)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202502181855001.png" alt="image-20250218185506888" loading="lazy"></p>
<h4 id="获取成员变量"><a href="#获取成员变量" class="headerlink" title="获取成员变量"></a>获取成员变量</h4><p><img src="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202502181855366.png" alt="image-20250218185552296" loading="lazy"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class clazz=Class.forName(&quot;全类名&quot;);</span><br><span class="line">Field[] fie1=clazz.getConstructors();</span><br><span class="line">for(Field field:fie2)&#123;</span><br><span class="line">System.out.println(con)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="获取成员方法"><a href="#获取成员方法" class="headerlink" title="获取成员方法"></a>获取成员方法</h4><p><img src="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202502181917171.png" alt="image-20250218191740079" loading="lazy"></p>
<h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>特点：无侵入式的给代码增加额外的功能</p>
<p>java通过接口保证，后面的对象和代理需要实现同一个接口，接口就是被代理的所有方法</p>
<h4 id="如何为Java对象创建代理对象"><a href="#如何为Java对象创建代理对象" class="headerlink" title="如何为Java对象创建代理对象"></a>如何为Java对象创建代理对象</h4><p><img src="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202502181510170.png" alt="image-20250218151025096" loading="lazy"></p>
<h3 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h3><p>IO流:存储和读取数据的解决方案</p>
<h4 id="IO流的分类"><a href="#IO流的分类" class="headerlink" title="IO流的分类"></a>IO流的分类</h4><p>按照流分为：输入流和写出流</p>
<p>按照操作文件类型分为：字节流（操作所有类型的文件）和字符流（操作纯文本文件，比如md和txt）</p>
<p>字节流：InputStream，OutputStream，FileInputStream（操作本地文件的字节输入流），FileOutputStream（操作本地文件的字节输出流）</p>
<p>字符流:：Reader，Write</p>
<p>它们都是抽象类</p>
<h4 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h4><p>操作本地文件的字节输出流，可以把程序中的数据写到本地文件中</p>
<p>书写步骤：</p>
<p>1、创建对象</p>
<p>1}.参数是字符串表示的路径或者是File对象都是可以的</p>
<p>2}.如果文件不存在会创建一个新的文件，但是要保证父级路径是存在的</p>
<p>3}.如果文件已存在，写入的东西会覆盖文件</p>
<p>2、写数据</p>
<p>1）write方法的参数是整数，但实际上写到文件的是整数在ASCII上对应的字符</p>
<p>3、释放资源</p>
<p>每次使用完流后要释放资源</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> myio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;E:\\web\\jav\\zuoye\\src\\myio\\a.txt&quot;</span>);</span><br><span class="line">        fos.write(<span class="number">97</span>);</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="FileOutputStream写数据的三种方式"><a href="#FileOutputStream写数据的三种方式" class="headerlink" title="FileOutputStream写数据的三种方式"></a>FileOutputStream写数据的三种方式</h5><p><img src="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202504162109989.png" alt="image-20250416210913912" loading="lazy"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> myio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        FileOutputStream fos=<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;E:\\web\\jav\\zuoye\\src\\myio\\a.txt&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] buf=&#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">100</span>&#125;;</span><br><span class="line">        fos.write(buf);<span class="comment">//abcd</span></span><br><span class="line">        fos.close();</span><br><span class="line">         fos.write(buf,<span class="number">0</span>,<span class="number">2</span>); <span class="comment">//ab</span></span><br><span class="line">        fos.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="换行写和续写"><a href="#换行写和续写" class="headerlink" title="换行写和续写"></a>换行写和续写</h5><p>换行写：传入一个\r\n</p>
<p>续写：将FileOutputStream第二个参数设置为true</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> myio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamDemo3</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 换行写:再写一个换行符</span></span><br><span class="line"><span class="comment">    *windows: \r\n</span></span><br><span class="line"><span class="comment">    * Linux: \n</span></span><br><span class="line"><span class="comment">    * Mac: \r</span></span><br><span class="line"><span class="comment">    * 细节：在windows操作系统中，java对回车换行进行了优化</span></span><br><span class="line"><span class="comment">    * 虽然完整的是\r\n，但是我们写其中一个\r或\n</span></span><br><span class="line"><span class="comment">    * java也是可以实现换行，因为java会在底层补全</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 续写</span></span><br><span class="line"><span class="comment">    * FileOutputStream第二个参数是续写功能，为bollean参数</span></span><br><span class="line"><span class="comment">    * 默认false</span></span><br><span class="line"><span class="comment">    * 手动传递true：表示打开续写,此是创建对象不会清空文件</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        FileOutputStream fos=<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;E:\\web\\jav\\zuoye\\src\\myio\\a.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//写数据换行</span></span><br><span class="line">        String str=<span class="string">&quot;wohaoshuai&quot;</span>;</span><br><span class="line">        fos.write(str.getBytes());</span><br><span class="line">        String str2=<span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">        fos.write(str2.getBytes());</span><br><span class="line">        String str3=<span class="string">&quot;666&quot;</span>;</span><br><span class="line">        fos.write(str2.getBytes());</span><br><span class="line">        fos.close();</span><br><span class="line">        <span class="comment">//续写</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h4><p>操作本地文件的字节输入流，可以把本地文件中的数据读取到程序中来。</p>
<p><strong>书写步骤：</strong></p>
<p>1、创建对象</p>
<p>如果文件不存在，就会直接报错。</p>
<p>2、读取数据</p>
<p>1）一次读一个字节，读出来的是数据在ASCII上对应的数字</p>
<p>2）读到文件末尾是，read方法返回-1</p>
<p>3、释放资源</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> myio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 实现需求:读取文件中的数据。(暂时不写中文)</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamDemo4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        FileInputStream fis=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;E:\\web\\jav\\zuoye\\src\\myio\\a.txt&quot;</span>);</span><br><span class="line">        <span class="type">int</span> b1= fis.read();</span><br><span class="line">        System.out.println((<span class="type">char</span>)b1);<span class="comment">//读到的是文件的第一个字母的ascii值</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="字节输入流循环读取"><a href="#字节输入流循环读取" class="headerlink" title="字节输入流循环读取"></a>字节输入流循环读取</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package myio;</span><br><span class="line"></span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 实现需求:读取文件中的数据。(暂时不写中文)</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">public class StreamDemo5 &#123;</span><br><span class="line">    public <span class="keyword">static</span> void <span class="title function_ invoke__">main</span>(<span class="type">String</span>[] args) throws IOException &#123;</span><br><span class="line">        FileInputStream fis=new <span class="title function_ invoke__">FileInputStream</span>(<span class="string">&quot;E:\\web\\jav\\zuoye\\src\\myio\\a.txt&quot;</span>);</span><br><span class="line">        int b;</span><br><span class="line">        <span class="keyword">while</span>((b=fis.<span class="title function_ invoke__">read</span>())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.<span class="title function_ invoke__">println</span>((<span class="type">char</span>)b);</span><br><span class="line">        &#125;</span><br><span class="line">        fis.<span class="title function_ invoke__">close</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a>文件拷贝</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> myio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamDemo6</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 文件拷贝</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.创建对象</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;E:\\web\\jav\\zuoye\\src\\myio\\a.txt&quot;</span>);</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;E:\\web\\jav\\zuoye\\src\\myio\\b.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拷贝</span></span><br><span class="line">        <span class="comment">//核心思想：边读边写</span></span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">        <span class="keyword">while</span>((b=fis.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        <span class="comment">//规则::先开的最后关闭</span></span><br><span class="line">        fos.close();</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="文件拷贝的弊端和解决方案"><a href="#文件拷贝的弊端和解决方案" class="headerlink" title="文件拷贝的弊端和解决方案"></a>文件拷贝的弊端和解决方案</h5><p>如果拷贝的文件过大，怎么处理</p>
<p>原因：FileInputStream一次读写一个字节</p>
<p>解决方法 </p>
<p><img src="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202504171924853.png" alt="image-20250417192433711" loading="lazy"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> myio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamDemo7</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * public int read(byte[] buffer) 一次读取一个字节</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        FileInputStream fis=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;E:\\web\\jav\\zuoye\\src\\myio\\b.txt&quot;</span>);<span class="comment">//woh</span></span><br><span class="line">        <span class="type">byte</span>[] bytes=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//一次读取多个字节数据，具体读多少，跟数组的长度有关</span></span><br><span class="line">        <span class="comment">//返回值:本次读取到多个数据</span></span><br><span class="line">        <span class="type">int</span> len=fis.read(bytes);</span><br><span class="line">        System.out.println(len);<span class="comment">//2</span></span><br><span class="line">        String str=<span class="keyword">new</span> <span class="title class_">String</span>(bytes);</span><br><span class="line">        System.out.println(str);<span class="comment">//wo</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> len1=fis.read(bytes);</span><br><span class="line">        System.out.println(len1);<span class="comment">//1</span></span><br><span class="line">        String str1=<span class="keyword">new</span> <span class="title class_">String</span>(bytes);</span><br><span class="line">        System.out.println(str1);<span class="comment">//ho</span></span><br><span class="line">        fis.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="FileInputString一次读多个字节"><a href="#FileInputString一次读多个字节" class="headerlink" title="FileInputString一次读多个字节"></a>FileInputString一次读多个字节</h5><p>  为什么上面第二个len的值为1，因为它是按照顺存将文件的字符存放在bytes数组中的</p>
<p>最开始是w和o，当第二次读取时，由于只剩下了一个h，就将h覆盖了w，于是输出了wo</p>
<p><img src="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202504171940279.png" alt="image-20250417194015197" loading="lazy"></p>
<p>解决方法：</p>
<p>使用new String(bytes,0,len)进行获取</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> myio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamDemo8</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;E:\\web\\jav\\zuoye\\src\\myio\\a.txt&quot;</span>);</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;E:\\web\\jav\\zuoye\\src\\myio\\b.txt&quot;</span>);</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line">        fis.close();</span><br><span class="line">        <span class="type">long</span> <span class="variable">l1</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(l1-l);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>拷贝很快</p>
<h4 id="IO流不同JDK版本捕获异常"><a href="#IO流不同JDK版本捕获异常" class="headerlink" title="IO流不同JDK版本捕获异常"></a>IO流不同JDK版本捕获异常</h4><p>try…catch…finally异常处理</p>
<p><img src="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202504172006574.png" alt="image-20250417200608502" loading="lazy"></p>
<p>但资源释放很麻烦</p>
<p><img src="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202504172030537.png" alt="image-20250417203018437" loading="lazy"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> myio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamDemo9</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *   JDK7:IO流中捕获异常的写法</span></span><br><span class="line"><span class="comment">        *       try后面的小括号中写创建对象的代码</span></span><br><span class="line"><span class="comment">        *       注意：只有实现了AutoCloseable接口的类，才能在小括号中创建对象</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line"><span class="comment">//        try(FileInputStream fis = new FileInputStream(&quot;E:\\web\\jav\\zuoye\\src\\myio\\a.txt&quot;);</span></span><br><span class="line"><span class="comment">//            FileOutputStream fos = new FileOutputStream(&quot;E:\\web\\jav\\zuoye\\src\\myio\\b.txt&quot;))</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            int len;</span></span><br><span class="line"><span class="comment">//            byte[] bytes = new byte[1024];</span></span><br><span class="line"><span class="comment">//            while ((len = fis.read(bytes)) != -1) &#123;</span></span><br><span class="line"><span class="comment">//                fos.write(bytes, 0, len);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;catch(IOException e)&#123;</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * JDK9:IO流中捕获异常的写法</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;E:\\web\\jav\\zuoye\\src\\myio\\a.txt&quot;</span>);</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;E:\\web\\jav\\zuoye\\src\\myio\\b.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>(fis;fos)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = fis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                fos.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="计算机存储规则"><a href="#计算机存储规则" class="headerlink" title="计算机存储规则"></a>计算机存储规则</h4><ol>
<li>在计算机中，任意数据都是以二进制的形式来存储的</li>
<li>计算机中最小的存储单元是一个字节</li>
<li>ASCII字符集中，一个英文占一个字节</li>
<li>简体中文版Windows，默认使用GBK字符集</li>
<li>GBK字符集完全兼容ASCII字符集<br>    一个英文占一个字节，二进制第一位是0<br>    一个中文占两个字节，二进制高位字节的第一位是1</li>
</ol>
<p><img src="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202504172100106.png" alt="image-20250417210049019" loading="lazy"></p>
<h5 id="unicode字符集"><a href="#unicode字符集" class="headerlink" title="unicode字符集"></a>unicode字符集</h5><p>unicode字符集：指某种语言或系统中可以使用的所有字符的集合</p>
<p>所以utf-8<strong>不是</strong>一个字符集，而是一种字节编码方式</p>
<p>编码方式有：</p>
<p>utf-16编码规则：用2到4个字节保存</p>
<p>utf-32编码规则：固定使用4个字节保存</p>
<p>utf-8编码规则：用1到4个字节保存，英文一个字节表示，中文3个字节表示</p>
<p><img src="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202504172132606.png" alt="image-20250417213233551" loading="lazy"></p>
<h5 id="为什么会出现乱码"><a href="#为什么会出现乱码" class="headerlink" title="为什么会出现乱码"></a>为什么会出现乱码</h5><p>原因：1.读取数据时未读完整个汉字</p>
<p>使用字节流读取时，因此只读取一个字节吗，但汉字由三个字节构成，因此只读取一个字节就会出现乱码</p>
<p>但使用拷贝时不会出现乱码</p>
<p>​			2.编码和解码时的方式不统一</p>
<p>解决方法：</p>
<p>1.不要使用字节流读取文本文件</p>
<p>2.编码解码时使用同一个码表，同一个编码方式</p>
<h4 id="java中编码和解码的代码实现"><a href="#java中编码和解码的代码实现" class="headerlink" title="java中编码和解码的代码实现"></a>java中编码和解码的代码实现</h4><p><img src="https://insey.oss-cn-shenzhen.aliyuncs.com/kin/202504172139792.png" alt="image-20250417213949713" loading="lazy"></p>
</div></section><ul class="post-copyright"><li class="post-copyright-author"><strong>Post author: </strong>kinsey</li><li class="post-copyright-link"><strong>Post link: </strong><a href="https://kinseyy.github.io/2024/11/12/Java/" title="Java">https://kinseyy.github.io/2024/11/12/Java/</a></li><li class="post-copyright-license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><span class="icon iconify" data-icon="ri:creative-commons-line"></span><span class="icon iconify" data-icon="ri:creative-commons-by-line"></span><span class="icon iconify" data-icon="ri:creative-commons-nc-line"></span><span class="icon iconify" data-icon="ri:creative-commons-sa-line"></span></a> unless otherwise stated.</li></ul></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2024/11/12/GKCTF-2021-CheckBot/" rel="prev" title="[GKCTF 2021]CheckBot"><span class="icon iconify" data-icon="ri:arrow-left-s-line"></span><span class="post-nav-text">[GKCTF 2021]CheckBot</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2024/11/12/JMCTF-2021-UploadHub/" rel="next" title="[JMCTF 2021]UploadHub"><span class="post-nav-text">[JMCTF 2021]UploadHub</span><span class="icon iconify" data-icon="ri:arrow-right-s-line"></span></a></div></div></div><div class="hty-card" id="comment"><div class="comment-tooltip text-center"><span>如果您有任何关于博客内容的相关讨论，欢迎前往 <a href="https://github.com/kinseyy/kinseyy.github.io/discussions" target="_blank">GitHub Discussions</a> 与我交流。</span><br></div><div id="waline"></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@waline/client@v2/dist/waline.css"><script>window.CONFIG.waline.config.path = "/2024/11/12/Java/"</script><div class="js-Pjax"><script src="/js/comments/waline.js" type="module" defer></script></div></div></main><footer class="sidebar-translate" id="footer"><div class="beian"><a rel="noopener" href="https://beian.miit.gov.cn/" target="_blank">苏ICP备17038157号</a></div><div class="copyright"><span>&copy; 2023 – 2025 </span><a class="with-love" id="animate" target="_blank" rel="noopener" href="https://github.com/kinseyy" title="Github"><span class="icon iconify" data-icon="ri:github-line"></span></a><span class="author"> kinsey</span></div><div class="powered"><span>Powered by <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> v7.2.0</span><span class="footer-separator">|</span><span>Theme - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.10.11</span></div><div class="footer-custom-text"><a href="https://www.travellings.cn/go.html" target="_blank" rel="noopener" title="开往-友链接力"><img src="https://www.travellings.cn/assets/logo.gif" alt="开往-友链接力" width="120"></a></div></footer></div><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><span class="icon iconify" data-icon="ri:arrow-up-s-line"></span><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a><a class="popup-trigger hty-icon-button icon-search" id="search" href="javascript:;" title="Search"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:search-line"></span></span></a><script>window.addEventListener("DOMContentLoaded", () => {
  // Handle and trigger popup window
  document.querySelector(".popup-trigger").addEventListener("click", () => {
    document.querySelector(".popup").classList.add("show");
    setTimeout(() => {
      document.querySelector(".search-input").focus();
    }, 100);
  });

  // Monitor main search box
  const onPopupClose = () => {
    document.querySelector(".popup").classList.remove("show");
  };

  document.querySelector(".popup-btn-close").addEventListener("click", () => {
    onPopupClose();
  });

  window.addEventListener("keyup", event => {
    if (event.key === "Escape") {
      onPopupClose();
    }
  });
});
</script><script defer src="https://fastly.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script><script defer src="https://fastly.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script><script defer src="/js/search/algolia-search.js" type="module"></script><div class="popup search-popup"><div class="search-header"><span class="popup-btn-close close-icon hty-icon-button"><span class="icon iconify" data-icon="ri:close-line"></span></span></div><div class="search-input-container"></div><div class="algolia-results"><div id="algolia-stats"></div><div id="algolia-hits"></div><div class="algolia-pagination" id="algolia-pagination"></div></div></div><script>function initMourn() {
  const date = new Date();
  const today = (date.getMonth() + 1) + "-" + date.getDate()
  const mourn_days = ["4-4","9-18"]
  if (mourn_days.includes(today)) {
    document.documentElement.style.filter = "grayscale(1)";
  }
}
initMourn();</script></body></html>